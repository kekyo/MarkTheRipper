---
title: タグとカテゴリ
lang: ja-jp
date: 10/26/2022 22:24:55 +09:00
---

タグとカテゴリによる分類は、ブログや論文のようなドキュメントを整理する場合に必要になります。
MarkTheRipperももちろんこれらを使って、記事の分類を行うことが出来ます。

## タグの集約

繰り返しの使い方さえ理解できれば、タグやカテゴリの操作は出来たも同然です。
MarkTheRipperは、コンテンツのすべてのタグとカテゴリの分類を、自動的に集約します。
タグについては、以下の特殊なキーワードで参照できます:

|キーワード|内容|
|:----|:----|
|`tags`|タグのリスト。各マークダウンのヘッダ部分に記述する|
|`tagList`|すべてのタグを集約したリスト|

まずはタグの一覧を作ってみましょう:

```html
<ul>
  {foreach tagList tag}
  <li>{tag}</li>
  {end}
</ul>
```

結果:

```html
<ul>
  <li>foo</li>
  <li>bar</li>
  <li>baz</li>
       :
</ul>
```

前節では、個々のマークダウンに定義された`tags`を使って繰り返しましたが、ここでは`tagList`を使っています。
この違いは、1つのマークダウンファイルではなく、MarkTheRipperが処理する全てのマークダウンのタグを集計した結果を扱っている事です。

つまり、`tagList`を使えば、タグによるメニュー項目やリンクリストを追加出来るようになります。
各タグの項目に、リンクを加えるにはどうすれば良いでしょうか？
タグだけでは、タグに紐づいたコンテンツ群は分かりませんが、実はタグは`foreach`で列挙することが出来ます:

```html
{foreach tagList tag}
<h1>{tag}</h1>
{foreach tag.entries entry}
<h2><a href="{entry.path}">{entry.title}</a></h2>
{end}
{end}
```

束縛名を指定して、何を列挙しようとしているのか分かりやすくしていることに注意してください。

`entries`プロパティを列挙すると、対応するマークダウン群の情報にアクセスできます。
この例のように`path`というプロパティを使用すると、コンテンツに対応するファイルへのパスが得られ、
`title`を使用すれば、そのタイトル（マークダウンのヘッダに記述された`title`）が得られます。

* `path`は、マークダウンへのパスではなく、変換されたHTMLファイルへのパスが得られます。

ところで、このパスは、出力ディレクトリを基準とした相対パスです。
HTMLにパスを埋め込む場合、HTMLファイルが存在するディレクトリからの相対パスである必要があります。
この計算を行うには、MarkTheRipper内蔵の関数キーワード `relative` を使います:

```html
<h2><a href="{relative entry.path}">{entry.title}</a></h2>
```

`relative`を使ってパスを計算すると、MarkTheRipperが出力したHTMLがどのサーバーにどのようにデプロイされたとしても、正しくリンクが機能するようになります。
ハードコーディングされたサイトの基準パスを使用するよりも、安全となるでしょう。

## カテゴリの集約

カテゴリについては、以下の特殊なキーワードで参照できます:

|キーワード|内容|
|:----|:----|
|`category`|カテゴリの階層リスト。各マークダウンのヘッダ部分に記述する|
|`rootCategory`|ルート(分類なし)となるカテゴリ|

タグとカテゴリが決定的に異なるのは、タグは並行して定義されるものであり、カテゴリは階層化を伴って定義されるものである事です。例えば:

```
(root) --+-- foo --+-- bar --+-- baz --+-- foobarbaz1.md
         |         |         |         +-- foobarbaz2.md
         |         |         |
         |         |         +-- foobar1.md
         |         |
         |         +--- foo1.md
         |         +--- foo2.md
         |         +--- foo3.md
         |
         +--- blog1.md
         +--- blog2.md
```

上の例では、`foobarbaz1.md`は、カテゴリ`foo/bar/baz`に属しています。
また、`blog1.md`は、どのカテゴリにも属していません。
MarkTheRipper内部では、無名の`(root)`カテゴリに属することになっています。
これが、`rootCategory`キーワードです。

タグの場合は`tags`キーワードを使用して定義しましたが、カテゴリの場合は`category`というキーワードを使用します。
上記の`foobarbaz1.md`に相当する定義は:

```markdown
---
title: Hello MarkTheRipper
category: foo,bar,baz
---

(... 本文 ...)
```

のように、階層をリストで指定します。タグと異なり、このリストは階層を表していることに注意してください。
CMSやサイトジェネレーターではこのような階層構造を、しばしば「パンくずリスト(breadcrumb)」と呼ぶことがあります。

ところで、MarkTheRipperは、このようにいちいち`category`キーワードでカテゴリを明示しなくても、コンテンツをカテゴリ分けされたサブディレクトリに配置するだけで、ディレクトリ名からカテゴリを決定出来ます。
従って、カテゴリによるコンテンツの分類は、サブディレクトリで区分けするだけで良いのです。

カテゴリの基本的な構造を把握出来たと思うので、実際にレイアウトを書いてみましょう。まずはルートカテゴリを列挙します:

```html
<h1>{rootCategory.name}</h1>
<ul>
  {foreach rootCategory.entries entry}
  <li>{entry.path}</li>
  {end}
</ul>
```

結果:

```html
<h1>(root)</h1>
<ul>
  <li>blog1.html</li>
  <li>blog2.html</li>
</ul>
```

`rootCategory`はルートカテゴリを表しているため、そのプロパティ`name`は`(root)`になります。
この名称が表示にふさわしくない場合は、キーワードの再帰検索を使って置き換えるか、またはこの例ではルートなので、直接書いてしまっても良いと思います。

そして、タグの時と同様に`entries`で列挙したそれぞれの要素から、各マークダウンのヘッダ情報を引き出すことが出来ます。
ここでは`path`を指定して、コンテンツのパスを出力していますが、`title`とすればタイトルが出力出来て、`relative item.path`とすれば、現在のコンテンツからの相対パスが得られるので、これをそのままリンクのURLにすることで、リンクを実現できます。

カテゴリを列挙するには、`children`プロパティを使います:

```html
<h1>{rootCategory.name}</h1>
{foreach rootCategory.children child1}
<h2>{child1.name}</h2>
{foreach child1.children child2}
<h3>{child2.name}</h3>
{end}
{end}
```

列挙のネストを増やしていけば、深いカテゴリ構造を全て列挙することが出来ます。
残念ながら、カテゴリ構造を動的に列挙する、つまり存在する子孫カテゴリまでを自動的に再帰的に列挙させる事は出来ません。
これは設計上の制約で、MarkTheRipperには、関数と再帰関数を定義する能力が無いためです。
（そのような要求は、恐らくサイト全体の構造リストを出力する場合だけであり、必要性を感じなかったためです）

カテゴリ操作の最後に、パンくずリストを出力する例を示します。これは非常に簡単です:

```html
<ul>
  {foreach category.breadcrumbs}
  <li>{item.name}</li>
  {end}
</ul>
```

`breadcrumbs`プロパティは、対象のカテゴリに至るカテゴリを、ルートから列挙出来る値を返します。
（但し、対象のカテゴリがルートの場合は、ルートカテゴリを含み、それ以外の場合は含みません）

列挙した個々の要素は、今まで説明してきたカテゴリと同様です。上記例では`name`プロパティでカテゴリ名を出力しています。
